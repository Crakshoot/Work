#!/bin/python
#//- This script is for monitoring docker container logs, triggering container restarts on key words/phrases,
#//- 	tracking id/name/image/status, and writing filtered logs to an alternative directory based on
#//-	container image name rather than ID to persist across multiple containers... -Bentz 

import os, sys, re, json, time

logPath = '/home/assessor/'

startTime = 0.0

updateDelay = 5

#//- TODO: Will try to add multiple use-cases here for more dynamic handling of different containers
restartTriggers = {
	'elasticsearch' : 'fatal error',
	'kibana' : 'fatal error',
	'brobeat' : 'fatal error',
	'snortbeat' : 'fatal error'
}


def getESResponse():
	response = str(os.popen("curl localhost:9200").read()).strip().split('\n')
	return response

def getDockerPS():
	containerData = {}
	containers = str(os.popen("docker ps -a").read()).strip().split('\n')
	containers.pop(0)
	i = 0
	for line in containers:
		data = line.split("  ")
		data = filter(None, data)
		containerData[i] = {}
		containerData[i]['id'] = data[0].strip()
		containerData[i]['name'] = data[5].strip()
		containerData[i]['image'] = data[1].strip()
		containerData[i]['status'] = data[4].strip()
		i += 1
	return containerData

def getDockerLogs(conId, opts='-t --since '+str(updateDelay)+'s'):
	#print("docker logs "+opts+" "+conId)
	logs = str(os.popen("docker logs "+opts+" "+conId).read()).strip().split('\n')
	return logs

def dockerRestart(conId):
	response = str(os.popen("docker restart "+conId).read()).strip()
	return response

def writeLog(logName, line):
	epochTime = time.time()
	logDate = time.strftime("%Y-%m-%d", time.gmtime())
	#logDateTime = time.strftime("%Y-%m-%d-%H-%M-%S", time.gmtime())
	logFile = logPath+logName+'-'+logDate+'.log'
	if not os.path.isfile(logFile):
		outHeaders = open(logFile, 'w')
		outHeaders.write("#//-AutoGenerated Log for tracking/fixing ElasticNodes toppling--Bentz\n")
		outHeaders.close()
	outFile = open(logFile, 'a')
	outFile.write(line+'\n')
	outFile.close()

def main():
	iteration = 0
	while(True):
		iteration += 1
		cycleTime = time.time()
		timeLeft = cycleTime + updateDelay - time.time()
		if timeLeft < 0:
			timeLeft = 0

		#response = getESResponse()
		#print response
		containers = getDockerPS()
		for i in containers:
			id = containers[i]['id']
			logs = getDockerLogs(id)
			for line in logs:
				words = line.split(" ")
				if "a fatal error" in line:
					#print words[0], "ERROR", line
					resp = dockerRestart(id)
					#print resp
					writeLog(containers[i]['name'],line)
					writeLog(containers[i]['name'],words[0]+"!!!ERROR DETECTED - TRIGGERED CONTAINER RESTART!!!")
					break
				elif "WARN" not in line:
					print line
					writeLog(containers[i]['name'],line)
					#print words[0], "WARNING"
				#else:
				#	print line
				#	writeLog(containers[i]['name'],line)
		print "[+] "+str(time.time())+" - Completed Cycle " + str(iteration) + ", waiting remaining %.2f seconds of interval" % timeLeft
		
		#if iteration == 480:
		#	print "Completed %s cycles, reloading hosts and clearing dictionary" % iteration
		#	sys.exit(1)
		time.sleep(timeLeft)
		
if __name__ == "__main__":
	startTime = time.gmtime()
	main()

